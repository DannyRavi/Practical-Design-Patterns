# Behavioural Patterns

<div dir="rtl">
- [Chain Of Responsibility](ChainOfResponsibility): با دادن بیشتر از یک شیء برای هندل کردن درخواست از جفتگری (کوپلینگ) فرستندهٔ درخواست و گیرندهٔ درخواست اجتناب می‌کند. اشیاء گیرنده را زنجیر می‌کند و درخواست را در امتداد زنجیر گذر می‌دهد تا زمانی که یکی از اشیاء آن را هندل کند.

- [Command](Command): درخواست را به عنوان یک شیء کپسوله می‌کند، از این رو اجازه می‌دهد تا بتوانید کارخوه‌ها را با درخواست‌ها، صف‌ها و یا لاگ‌های متفاوت پارامتری کنید.

- [Interpreter](Interpreter): یک بازنمایی برای گرامر زبان داده شده تعریف می‌کند و مفسر توسط این باز نمایی، جملات زبان را تفسیر می کند.

- [Iterator](Iterator): روشی برای دستری به عناصر یک شیء اگریگیت فراهم می‌کند بدون اینکه اصول پیاده‌سازی و ساختمان دادهٔ لایهٔ زیرین اگریگیت را نمایش دهد.

- [Mediator](Mediator): شیء‌ای را تعریف می‌کند که نحوهٔ ارتباط بین مجوعه‌ای از اشیاء را کپسوله می‌کند. این الگو با جلوگیری ارتباط صریح بین اشیاء از جفتگری ضعیف (loose coupling) پشتیبانی می‌کند.

- [Memento](Memento): بدون تخلف از کپسوله‌سازی، وضعیت داخلی شیء ضبط و استخراج می‌کند از این رو شیء بعداً می‌تواند به این حالت برگردد.

- [Observer](Observer): وابستگی یک-به-چند بین اشیاء تعریف می‌کند بنابراین وقتی یک شیء وضعیت‌اش را تغییر می‌دهد، تمامی اشیاء وابسته به آن از آن تغییر مطلع شده و به صورت خودکار به روز می‌شوند.

- [State](State): به شیء این اجازه را می‌دهد که وقتی وضعیت درونی‌اش تغییر کرد، رفتارش را تغییر دهد. به نظر می‌رسد که شیء کلاس خود را عوض می‌کند.

- [Strategy](Strategy): خانواده‌ای از الگوریتم ها را تعریف می‌کند، هر یک را کپسوله می‌کند و آن‌ها را جابه‌جا پذیر می‌کند. الگوی استراتژی اجازه می‌دهد که الگوریتم‌ها مستقل از کارخواهی که از آن‌ها استفاده می‌کند، تغییر کنند.

- [Template Method](TemplateMethod): استخوان‌بندی و شالودهٔ اصلی عملیات الگوریتم را تعریف می‌کند، و پیاده‌سازی هر مرحله را به زیرکلاس‌ها می‌سپارد. این الگو، به زیرکلاس‌ها این اختیار را می‌دهد که تا خودشان، مراحل الگوریتم را پیاده کنند بدون اینکه ساختار الگوریتم را تغییر دهند.

- [Visitor](Visitor): اعمالی که باید روی عناصری از شیء اجرا شود را ارائه می‌کند. این الگو اجازه را می‌دهد تا اعمال جدیدی تعریف کنید بدون اینکه کلاس‌هایی که این اعمال روی آن‌ها انجام می‌شود را تغییر دهید.


